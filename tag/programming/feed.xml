<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Abel Soares Siqueira</title>
        <link>https://abelsiqueira.github.io/tag/programming/feed.xml</link>
        <description>RSS feed for abelsiqueira.github.io</description>
        <lastBuildDate>Fri, 23 Dec 2022 17:40:54 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/nuxt-community/feed-module</generator>
        <category>Nuxt.js</category>
        <item>
            <title><![CDATA[Games for Programmers]]></title>
            <link>https://abelsiqueira.github.io/blog/2016-03-20-games-for-programmers</link>
            <guid>https://abelsiqueira.github.io/blog/2016-03-20-games-for-programmers</guid>
            <pubDate>Sun, 20 Mar 2016 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
# Games for Programmers

Ever since I can remember I liked puzzles. My father had a book on puzzles, and
there were also puzzle magazines. I liked it much
I also liked gaming very much. I don't remember where it started, but I played
a lot.
Well, today I'll talk about games that have programming involved, albeit
indirectly.

## [Light-Bot](http://www.kongregate.com/games/Coolio_Niato/light-bot)

This is a very simple game at first. It scales after some levels, but a
programmer shouldn't have much trouble completing it.
For a non-programmer, it is a great starting point. It really is made for
beginners.

There is also a Light-Bot 2.0, which you can continue after.

They also made Light-Bot Rewired, but that is only the first game again to get
money from you.

## [Tile Factory](http://www.kongregate.com/games/duerig/tile-factory)

This is a good continuation. It is very big, but it starts easy enough.
After some levels you will get some headache with timing and "crossing lanes",
but it still very good.
The [source was
opened](https://github.com/Tile-Factory-Unbound/tile-factory-unbound)
some time ago, so maybe a continuation can be made from interest people.
Tell me it that's the case.

## [Manufactoria](http://www.kongregate.com/games/PleasingFungus/manufactoria)

Now things get ugly (or beautiful). This game really increases the difficulty.
You must use conditionals and loops from the early game.
This is easily my favorite of the list, althought it is very hard.
I can't even remember if I finished all levels (in part because I eventually
have to change computers and start again).

If you already are a programmer, you have to try it.

## Other games

Some other games I must mention:

- [KOHCTPYKTOP](http://www.kongregate.com/games/krispykrem/kohctpyktop-engineer-of-the-people):
  A game in which you design integrated circuits. It involves a little more
  knowledge of circuits than I have, so it became quite hard to do anything.
- [The Codex of Alchemical
  Engineering](http://www.kongregate.com/games/krispykrem/the-codex-of-alchemical-engineering):
  This is similar to lightbot, but a little more difficult. For some reason, I
  didn't enjoyed this enough.

All these games were played on Kongregate because I spent a lot of time on that,
but most can be played on other sites too.
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[The End of Fortran]]></title>
            <link>https://abelsiqueira.github.io/blog/2014-11-22-the-end-of-fortran</link>
            <guid>https://abelsiqueira.github.io/blog/2014-11-22-the-end-of-fortran</guid>
            <pubDate>Sat, 22 Nov 2014 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
# The End of Fortran

One of my main interest is the end of Fortran **as the only programming language
used by mathematicias**. If you're not in the area of mathematical programming,
you probably find it strange for me to be talking about Fortran, so I explain.
Fortran is considered the fastest programming language in mathematics, and most
things made are in this language. Other often used languages such as
MatLab/Octave and Mathematica are high-level, which means they are slower and
are not considered for serious applications.

In reality, Fortran is one of the fastest programming language **for linear
algebra with dense matrices**. Since most things in this area are matrices, and
most vectors are dense, this can't be overlooked. In addition, fortran has a
relatively easy way to go, bypassing the painstankingly formatting and GOTO,
which were left behind by the newer versions.

The problem is that, since learning Fortran is almost imperative in the area,
there is little else used to code in the area. Hence, easy tasks without need of
fast execution become hard programming jobs. And furthermore, tasks that need
fast execution, but can't (shouldn't) be implement as matrices, become slow in
Fortran, and sometimes this is overlooked.

My proposition is **use the best tool for the job**, which is just common sense,
but applied to our area. Try [Python](http://www.python.org). Try
[Ruby](http://www.ruby-lang.org). Try [Julia](http://www.julialang.org). Try
to implementing a graph using a list of pointers. Try to implement a argument
parser. Try to implement reading, storing, and calculating the transpose of a
sparse matrix. Try to implement a tool to read all citations on your .tex, read
from a bibtex file such references and print then all in a nice format.

Now, rather than stay in that language, go for another. Try other languages.
When the job comes, you can choose the best tool for it. And you can combine.
Some languages, such as Julia, Fortran and C, are very easy to combine with
others. Implement your algorithm in Julia, then improve it later with Fortran.
And if you are really in need of speed, why not implement the hardest part in
machine language (ASSEMBLY)?
Implementing the fastest possible algorithm is very good for a specific
application, but in our line of work, we must take into account the method, not
only the implementation.
]]></content:encoded>
        </item>
    </channel>
</rss>