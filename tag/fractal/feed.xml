<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/">
    <channel>
        <title>Abel Soares Siqueira</title>
        <link>https://abelsiqueira.github.io/tag/fractal/feed.xml</link>
        <description>RSS feed for abelsiqueira.github.io</description>
        <lastBuildDate>Fri, 23 Dec 2022 14:24:34 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>https://github.com/nuxt-community/feed-module</generator>
        <category>Nuxt.js</category>
        <item>
            <title><![CDATA[Koch snowflakes for the holidays]]></title>
            <link>https://abelsiqueira.github.io/blog/2018-12-12-koch-snowflakes-for-the-holidays</link>
            <guid>https://abelsiqueira.github.io/blog/2018-12-12-koch-snowflakes-for-the-holidays</guid>
            <pubDate>Wed, 12 Dec 2018 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
# Koch snowflakes for the holidays

[Code for these images](https://github.com/abelsiqueira/koch-holidays).

I hope you're familiar with the [Koch curve
fractal or snowflake](https://en.wikipedia.org/wiki/Koch_snowflake).
It essentially consists taking a line segment, splitting it in three, and substituting
the middle part by two segments that form an equilateral triangle without the base.
From one segment you obtain four. For each new segment, repeat the process.

Images:

![](/blog/koch/line-koch-0.png)

![](/blog/koch/line-koch-1.png)
![](/blog/koch/line-koch-2.png)
![](/blog/koch/line-koch-3.png)
![](/blog/koch/line-koch-4.png)
![](/blog/koch/line-koch-5.png)
![](/blog/koch/line-koch-6.png)
![](/blog/koch/line-koch-7.png)

The most important aspect of the koch line is that it looks awesome. Furthermore, you
can do it for any image that is a collection of segments. In particular, regular
polygons, both outward and inward.

![](/blog/koch/polygon-2.png)
![](/blog/koch/polygon-reverse-2.png)
![](/blog/koch/polygon-3.png)
![](/blog/koch/polygon-reverse-3.png)
![](/blog/koch/polygon-4.png)
![](/blog/koch/polygon-reverse-4.png)
![](/blog/koch/polygon-5.png)
![](/blog/koch/polygon-reverse-5.png)
![](/blog/koch/polygon-6.png)
![](/blog/koch/polygon-reverse-6.png)
![](/blog/koch/polygon-7.png)
![](/blog/koch/polygon-reverse-7.png)
![](/blog/koch/polygon-8.png)
![](/blog/koch/polygon-reverse-8.png)

Another way to define the four new segments is this: Given the endpoints of the segment
$P_1$ and $P_2$, we define $\vec{v} = \vec{P_1P_2}$. The five points that define the
four new segments, in order, are $P_1$, $P_1 + \frac{1}{3}\vec{v}$,
$P_1 + \frac{1}{2}\vec{v} + \alpha R\vec{v}$, $P1 + \frac{2}{3}\vec{v}$ and $P_2$,
where $\alpha = \sqrt{3}/6$.
A simple thing one can do is change the value of $\alpha$ to obtain different images:

![](/blog/koch/star.png)
Using a diamond with $\alpha = 1.25$.

![](/blog/koch/reverse-star.png)
Using a square with $\alpha = 1.2$.

![](/blog/koch/stargon-3.png)
![](/blog/koch/stargon-4.png)
![](/blog/koch/stargon-5.png)
Using polygons with $N$ equals to 3, 4 and 5 sides, and $\alpha = 3\sqrt{N}/5$.

![](/blog/koch/tri-3.png)
![](/blog/koch/tri-4.png)
![](/blog/koch/tri-5.png)
Using a line segment from the center to the vertex and back and to next vertex, etc.,
with $\alpha = 1$.

And to close off, here's a traditional triangle, repeated, with alternating colors.
![](/blog/koch/koch.png)

[Here a larger scale version](/blog/koch/koch-large.png)
![](/blog/koch/koch-large.png)

Happy holidays!
![](/blog/koch/koch-julia.png)
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[Julia Fractal on Julia]]></title>
            <link>https://abelsiqueira.github.io/blog/2017-01-15-julia-fractal-on-julia</link>
            <guid>https://abelsiqueira.github.io/blog/2017-01-15-julia-fractal-on-julia</guid>
            <pubDate>Sun, 15 Jan 2017 00:00:00 GMT</pubDate>
            <content:encoded><![CDATA[
# Julia Fractal on Julia

I wanted a background that would update automatically in some
interesting way, instead of just random images.
After some thought, I decided to use some [Julia
fractals](https://en.wikipedia.org/wiki/Julia_set).

I made a code to create the Julia fractals in the [Julia
language](https://julialang.org), and then some code to run it for a random
point.

The code is [here](https://github.com/abelsiqueira/juliabg), including some
explaining on how to use and install it.

Here are some examples:

![](https://raw.githubusercontent.com/abelsiqueira/juliabg/master/ex1.png)
![](https://raw.githubusercontent.com/abelsiqueira/juliabg/master/ex2.png)
![](https://raw.githubusercontent.com/abelsiqueira/juliabg/master/ex3.png)
![](https://raw.githubusercontent.com/abelsiqueira/juliabg/master/ex4.png)
]]></content:encoded>
        </item>
    </channel>
</rss>