__NUXT_JSONP__("/blog/2014-11-22-the-end-of-fortran", (function(a,b,c,d,e,f,g,h,i,j,k,l){return {data:[{page:{slug:"2014-11-22-the-end-of-fortran",title:k,date:"2014-11-22",tags:["rant","programming","fortran","julia"],toc:[],body:{type:"root",children:[{type:b,tag:"h1",props:{id:"the-end-of-fortran"},children:[{type:b,tag:e,props:{href:"#the-end-of-fortran",ariaHidden:"true",tabIndex:-1},children:[{type:b,tag:"span",props:{className:["icon","icon-link"]},children:[]}]},{type:a,value:k}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"One of my main interest is the end of Fortran "},{type:b,tag:f,props:{},children:[{type:a,value:"as the only programming language\nused by mathematicias"}]},{type:a,value:". If you're not in the area of mathematical programming,\nyou probably find it strange for me to be talking about Fortran, so I explain.\nFortran is considered the fastest programming language in mathematics, and most\nthings made are in this language. Other often used languages such as\nMatLab\u002FOctave and Mathematica are high-level, which means they are slower and\nare not considered for serious applications."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"In reality, Fortran is one of the fastest programming language "},{type:b,tag:f,props:{},children:[{type:a,value:"for linear\nalgebra with dense matrices"}]},{type:a,value:". Since most things in this area are matrices, and\nmost vectors are dense, this can't be overlooked. In addition, fortran has a\nrelatively easy way to go, bypassing the painstankingly formatting and GOTO,\nwhich were left behind by the newer versions."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"The problem is that, since learning Fortran is almost imperative in the area,\nthere is little else used to code in the area. Hence, easy tasks without need of\nfast execution become hard programming jobs. And furthermore, tasks that need\nfast execution, but can't (shouldn't) be implement as matrices, become slow in\nFortran, and sometimes this is overlooked."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"My proposition is "},{type:b,tag:f,props:{},children:[{type:a,value:"use the best tool for the job"}]},{type:a,value:", which is just common sense,\nbut applied to our area. Try "},{type:b,tag:e,props:{href:"http:\u002F\u002Fwww.python.org",rel:[g,h,i],target:j},children:[{type:a,value:"Python"}]},{type:a,value:". Try\n"},{type:b,tag:e,props:{href:"http:\u002F\u002Fwww.ruby-lang.org",rel:[g,h,i],target:j},children:[{type:a,value:"Ruby"}]},{type:a,value:". Try "},{type:b,tag:e,props:{href:"http:\u002F\u002Fwww.julialang.org",rel:[g,h,i],target:j},children:[{type:a,value:"Julia"}]},{type:a,value:". Try\nto implementing a graph using a list of pointers. Try to implement a argument\nparser. Try to implement reading, storing, and calculating the transpose of a\nsparse matrix. Try to implement a tool to read all citations on your .tex, read\nfrom a bibtex file such references and print then all in a nice format."}]},{type:a,value:c},{type:b,tag:d,props:{},children:[{type:a,value:"Now, rather than stay in that language, go for another. Try other languages.\nWhen the job comes, you can choose the best tool for it. And you can combine.\nSome languages, such as Julia, Fortran and C, are very easy to combine with\nothers. Implement your algorithm in Julia, then improve it later with Fortran.\nAnd if you are really in need of speed, why not implement the hardest part in\nmachine language (ASSEMBLY)?\nImplementing the fastest possible algorithm is very good for a specific\napplication, but in our line of work, we must take into account the method, not\nonly the implementation."}]}]},dir:"\u002Fblog",path:"\u002Fblog\u002F2014-11-22-the-end-of-fortran",extension:".md",createdAt:l,updatedAt:l,bodyPlainText:"\n# The End of Fortran\n\nOne of my main interest is the end of Fortran **as the only programming language\nused by mathematicias**. If you're not in the area of mathematical programming,\nyou probably find it strange for me to be talking about Fortran, so I explain.\nFortran is considered the fastest programming language in mathematics, and most\nthings made are in this language. Other often used languages such as\nMatLab\u002FOctave and Mathematica are high-level, which means they are slower and\nare not considered for serious applications.\n\nIn reality, Fortran is one of the fastest programming language **for linear\nalgebra with dense matrices**. Since most things in this area are matrices, and\nmost vectors are dense, this can't be overlooked. In addition, fortran has a\nrelatively easy way to go, bypassing the painstankingly formatting and GOTO,\nwhich were left behind by the newer versions.\n\nThe problem is that, since learning Fortran is almost imperative in the area,\nthere is little else used to code in the area. Hence, easy tasks without need of\nfast execution become hard programming jobs. And furthermore, tasks that need\nfast execution, but can't (shouldn't) be implement as matrices, become slow in\nFortran, and sometimes this is overlooked.\n\nMy proposition is **use the best tool for the job**, which is just common sense,\nbut applied to our area. Try [Python](http:\u002F\u002Fwww.python.org). Try\n[Ruby](http:\u002F\u002Fwww.ruby-lang.org). Try [Julia](http:\u002F\u002Fwww.julialang.org). Try\nto implementing a graph using a list of pointers. Try to implement a argument\nparser. Try to implement reading, storing, and calculating the transpose of a\nsparse matrix. Try to implement a tool to read all citations on your .tex, read\nfrom a bibtex file such references and print then all in a nice format.\n\nNow, rather than stay in that language, go for another. Try other languages.\nWhen the job comes, you can choose the best tool for it. And you can combine.\nSome languages, such as Julia, Fortran and C, are very easy to combine with\nothers. Implement your algorithm in Julia, then improve it later with Fortran.\nAnd if you are really in need of speed, why not implement the hardest part in\nmachine language (ASSEMBLY)?\nImplementing the fastest possible algorithm is very good for a specific\napplication, but in our line of work, we must take into account the method, not\nonly the implementation.\n"},prev:{slug:"2014-12-11-siclipod-um-gerenciador-de-podcasts-simples-em-linha-de-comando",title:"SiCLIPoD - Um Gerenciador de Podcasts Simples em Linha de Comando"},next:{slug:"2014-11-22-caminho-academico",title:"Caminho AcadÃªmico"}}],fetch:{},mutations:void 0}}("text","element","\n","p","a","strong","nofollow","noopener","noreferrer","_blank","The End of Fortran","2022-12-23T23:04:30.331Z")));